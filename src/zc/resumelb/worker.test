Basic, single-connection tests
==============================

Workers act as wsgi servers, accepting requests and sending responses
using serialized wsgi (not web requests).

Now, let's create a worker:

    >>> import zc.resumelb.worker, zc.resumelb.tests
    >>> worker = zc.resumelb.worker.Worker(
    ...   zc.resumelb.tests.app(), ('127.0.0.1', 0), dict(history=5))

Here we created a worker using a test application, telling it to
an address to listen on and to update it's resume after every
five requests.

Note that we passed 0 as the address port. This causes an ephemeral
port to be used. We can get the actual address using ``worker.addr``.

Now, we'll connect to the worker:

    >>> import gevent.socket
    >>> worker_socket = gevent.socket.create_connection(worker.addr)

Workers and the lb communicate via sized messages.

Each message consists of binary request numbers, data size and a
marshalled data string.  Helper functions help us read and write
messages.  When workers accept a connection, they send their resume
and then wait for work to do.  Because our worker has no experience
:), it's resume is empty:

    >>> from zc.resumelb.util import read_message, write_message
    >>> read_message(worker_socket)
    (0, {})

When the worker sends it's resume, it sends 0 as the request number.

Now, let's send a request to the worker.  Requests are based on wsgi
environments. We'll use webob to help us set this up.

    >>> import webob
    >>> def newenv(rclass, *a, **kw):
    ...     r = webob.Request.blank(*a, **kw)
    ...     env = r.environ.copy()
    ...     inp = env.pop('wsgi.input')
    ...     del env['wsgi.errors']
    ...     env['zc.resumelb.request_class'] = rclass
    ...     return env

    >>> env = newenv('', '/hi.html')

The newenv helper:

- Creates a request environ
- without input or error streams
- with a passed request class. The request class is needed for the resume.

    >>> write_message(worker_socket, 1, env, '')

write_message takes a socket to write to, a request number and one or
more data objects.  Here, we passed 2 data objects, the request
environment and an empty string indicating the end of the (empty)
request body.

The worker will process the request and send back 3 records:

- response status and headers,
- response body, and
- an empty end-of-body message.

    >>> def print_response(worker_socket, rno, size_only=False):
    ...     d = read_message(worker_socket)
    ...     try: rn, (status, headers) = d
    ...     except:
    ...       print 'wtf', `d`
    ...       return
    ...     #rn, (status, headers) = read_message(worker_socket)
    ...     if rn != rno:
    ...        raise AssertionError("Bad request numbers", rno, rn)
    ...     print rno, status
    ...     for h in sorted(headers):
    ...         print "%s: %s" % h
    ...     print
    ...     size = 0
    ...     while 1:
    ...         rn, data = read_message(worker_socket)
    ...         if rn != rno:
    ...            raise AssertionError("Bad request numbers", rno, rn)
    ...         if data:
    ...             if size_only:
    ...                 size += len(data)
    ...             else:
    ...                 print data,
    ...         else:
    ...             break
    ...     if size_only:
    ...        print size

    >>> print_response(worker_socket, 1)
    1 200 OK
    Content-Length: 79
    Content-Type: text/html; charset=UTF-8; charset=UTF-8
    <BLANKLINE>
    <BLANKLINE>
    <BLANKLINE>
    http://localhost/hi.html -> 6115 0 da39a3ee5e6b4b0d3255bfef95601890afd80709
    <BLANKLINE>

We can have multiple outstanding requests:

    >>> write_message(worker_socket, 2, newenv('', '/hi.html'))
    >>> write_message(worker_socket, 3, newenv('1', '/hi.html'))
    >>> write_message(worker_socket, 4, newenv('1', '/hi.html'))

At this point, we have 3 outstading requests.  Let's create 3 bodies:

    >>> b2 = 'x'*1000
    >>> b3 = 'y'*10000
    >>> b4 = 'z'*100000

    >>> import hashlib
    >>> sha1 = lambda s: hashlib.sha1(s).hexdigest()

    >>> sha1(b2)
    'c3efa690fa3fdd2e2526853eed670538ea127638'
    >>> sha1(b3)
    'c1d5e830a1027a7b5de9e0620f3a2497d6b60c3e'
    >>> sha1(b4)
    '3235771c66bf77697df635e1bce4173668d2ea32'

and send them:

    >>> write_message(worker_socket, 2, b2)
    >>> write_message(worker_socket, 3, b3[:5000])
    >>> write_message(worker_socket, 4, b4[:5000])
    >>> write_message(worker_socket, 4, b4[5000:10000])
    >>> write_message(worker_socket, 3, b3[5000:10000])
    >>> for i in range(1, 10):
    ...     write_message(worker_socket, 4, b4[i*10000:(i+1)*10000])

    >>> write_message(worker_socket, 4, '')
    >>> print_response(worker_socket, 4) # doctest: +NORMALIZE_WHITESPACE
    4 200 OK
    Content-Length: 84
    Content-Type: text/html; charset=UTF-8; charset=UTF-8
    <BLANKLINE>
    <BLANKLINE>
    <BLANKLINE>
    http://localhost/hi.html ->
    6115 100000 3235771c66bf77697df635e1bce4173668d2ea32
    <BLANKLINE>

    >>> write_message(worker_socket, 2, '')
    >>> print_response(worker_socket, 2) # doctest: +NORMALIZE_WHITESPACE
    2 200 OK
    Content-Length: 82
    Content-Type: text/html; charset=UTF-8; charset=UTF-8
    <BLANKLINE>
    <BLANKLINE>
    <BLANKLINE>
    http://localhost/hi.html ->
    6115 1000 c3efa690fa3fdd2e2526853eed670538ea127638
    <BLANKLINE>

    >>> write_message(worker_socket, 3, '')
    >>> print_response(worker_socket, 3) # doctest: +NORMALIZE_WHITESPACE
    3 200 OK
    Content-Length: 83
    Content-Type: text/html; charset=UTF-8; charset=UTF-8
    <BLANKLINE>
    <BLANKLINE>
    <BLANKLINE>
    http://localhost/hi.html ->
    6115 10000 c1d5e830a1027a7b5de9e0620f3a2497d6b60c3e
    <BLANKLINE>

The handler for hi.html outputs the url, the pid, the request body
size and the request body hash.  Note that the hashes match the test
bodies we created.

We told the worker to use a history of length 5.  This means that it
will keep track of times for the last 5 requests and compute a new
resume after 5 requests.  Let's test that by making a 5th request.

    >>> write_message(worker_socket, 5, newenv('2', '/sleep.html?dur=.11'), '')
    >>> print_response(worker_socket, 5)
    5 200 OK
    Content-Length: 12
    Content-Type: text/html; charset=UTF-8; charset=UTF-8
    <BLANKLINE>
    hello world

The next message we recieve will be the new resume:

    >>> zero, resume = read_message(worker_socket)
    >>> zero, resume.keys(), [x for x in resume.values() if type(x) != float]
    (0, ['', '1', '2'], [])

    >>> resume[''] > 10, resume['1'] > 10, resume['2'] < 10
    (True, True, True)

The numbers in the resumes are average requests per second.  For the
last request, we sleep .11 seconds to assure that it's resume entry
would be less than 10.

We can reuse request numbers. We normally don't reuse request numbers
until we get to 4 billion or so., But lets make sure we can reuse
them:

    >>> write_message(worker_socket, 1, newenv('', '/gen.html?size=100'), '')

In this example, we've also requested a very large output.

    >>> print_response(worker_socket, 1, size_only=True)
    1 200 OK
    Content-Length: 1200000
    Content-Type: text/html; charset=UTF-8
    <BLANKLINE>
    1200000

Multiple connections (multiple load balancers)
==============================================

In a production deployment, there will likely be multiple load
balancers for redundancy.  In this case, there are multiple
connections to workers.  Let's excercise that and make sure it works
properly.

Open a second connection:

    >>> worker_socket2 = gevent.socket.create_connection(worker.addr)

We're immediately send the worker's resume -- same as the old.

    >>> read_message(worker_socket2) == (zero, resume)
    True

And send simultaneous requests to each connection:

    >>> write_message(worker_socket,  2, newenv('1', '/hi.html'))
    >>> write_message(worker_socket2, 2, newenv('2', '/hi.html'))
    >>> write_message(worker_socket,  3, newenv('1', '/hi.html'))
    >>> write_message(worker_socket2, 3, newenv('2', '/hi.html'))
    >>> write_message(worker_socket,  4, newenv('1', '/hi.html'))
    >>> write_message(worker_socket2, 4, newenv('2', '/hi.html'))

And pretty much repeat the multi-connection test we did for one worker:

    >>> b22 = 'i'*1000
    >>> b32 = 'j'*10000
    >>> b42 = 'k'*100000

    >>> sha1(b22)
    'bbf78f200f29636bb75c85467c1319e57a0d4149'
    >>> sha1(b32)
    '44bd0dbf8208fea52dc6180376d14798b86847bd'
    >>> sha1(b42)
    'd10948c2d88f13ea561a09157dd263c38527b2b6'


    >>> write_message(worker_socket, 2, b2)
    >>> write_message(worker_socket2, 2, b22)
    >>> write_message(worker_socket, 3, b3[:5000])
    >>> write_message(worker_socket2, 3, b32[:5000])
    >>> write_message(worker_socket, 4, b4[:5000])
    >>> write_message(worker_socket2, 4, b42[:5000])
    >>> write_message(worker_socket, 4, b4[5000:10000])
    >>> write_message(worker_socket2, 4, b42[5000:10000])
    >>> write_message(worker_socket, 3, b3[5000:10000])
    >>> write_message(worker_socket2, 3, b32[5000:10000])
    >>> for i in range(1, 10):
    ...     write_message(worker_socket, 4, b4[i*10000:(i+1)*10000])
    ...     write_message(worker_socket2, 4, b42[i*10000:(i+1)*10000])

    >>> write_message(worker_socket, 4, '')
    >>> print_response(worker_socket, 4) # doctest: +NORMALIZE_WHITESPACE
    4 200 OK
    Content-Length: 84
    Content-Type: text/html; charset=UTF-8; charset=UTF-8
    <BLANKLINE>
    <BLANKLINE>
    <BLANKLINE>
    http://localhost/hi.html ->
    6115 100000 3235771c66bf77697df635e1bce4173668d2ea32
    <BLANKLINE>

And on with our simultaneous request on multiple worker test.

    >>> write_message(worker_socket2, 4, '')
    >>> print_response(worker_socket2, 4) # doctest: +NORMALIZE_WHITESPACE
    4 200 OK
    Content-Length: 84
    Content-Type: text/html; charset=UTF-8; charset=UTF-8
    <BLANKLINE>
    <BLANKLINE>
    <BLANKLINE>
    http://localhost/hi.html ->
    6115 100000 d10948c2d88f13ea561a09157dd263c38527b2b6
    <BLANKLINE>

    >>> write_message(worker_socket, 2, '')
    >>> print_response(worker_socket, 2) # doctest: +NORMALIZE_WHITESPACE
    2 200 OK
    Content-Length: 82
    Content-Type: text/html; charset=UTF-8; charset=UTF-8
    <BLANKLINE>
    <BLANKLINE>
    <BLANKLINE>
    http://localhost/hi.html ->
    6115 1000 c3efa690fa3fdd2e2526853eed670538ea127638
    <BLANKLINE>

    >>> write_message(worker_socket2, 2, '')
    >>> print_response(worker_socket2, 2) # doctest: +NORMALIZE_WHITESPACE
    2 200 OK
    Content-Length: 82
    Content-Type: text/html; charset=UTF-8; charset=UTF-8
    <BLANKLINE>
    <BLANKLINE>
    <BLANKLINE>
    http://localhost/hi.html ->
    6115 1000 bbf78f200f29636bb75c85467c1319e57a0d4149
    <BLANKLINE>


We're due for another resume.  We should get it on both sockets!

    >>> zero, resume = read_message(worker_socket)
    >>> zero, resume.keys(), [x for x in resume.values() if type(x) != float]
    (0, ['', '1', '2'], [])

    >>> read_message(worker_socket2) == (zero, resume)
    True


    >>> write_message(worker_socket, 3, '')
    >>> print_response(worker_socket, 3) # doctest: +NORMALIZE_WHITESPACE
    3 200 OK
    Content-Length: 83
    Content-Type: text/html; charset=UTF-8; charset=UTF-8
    <BLANKLINE>
    <BLANKLINE>
    <BLANKLINE>
    http://localhost/hi.html ->
    6115 10000 c1d5e830a1027a7b5de9e0620f3a2497d6b60c3e
    <BLANKLINE>

    >>> write_message(worker_socket2, 3, '')
    >>> print_response(worker_socket2, 3) # doctest: +NORMALIZE_WHITESPACE
    3 200 OK
    Content-Length: 83
    Content-Type: text/html; charset=UTF-8; charset=UTF-8
    <BLANKLINE>
    <BLANKLINE>
    <BLANKLINE>
    http://localhost/hi.html ->
    6115 10000 44bd0dbf8208fea52dc6180376d14798b86847bd
    <BLANKLINE>

Cleanup:

    >>> worker.stop()
