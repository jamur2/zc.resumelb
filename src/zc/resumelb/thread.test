resumelb thread pool
====================

Applications bloc.

To deal with this, we provide a very basic thread pool.

    >>> import zc.resumelb.thread

    >>> pool = zc.resumelb.thread.Pool(4)

We specified a pool size of 4, so 4 threads are created:

    >>> import threading
    >>> len([t for t in threading.enumerate()
    ...      if t.name == 'zc.resumelb.thread'])
    4

They are all deamonic:

    >>> len([t for t in threading.enumerate()
    ...      if t.name == 'zc.resumelb.thread'])
    4

To get something done, call the pool result method with a callable and
arguments:

    >>> import time
    >>> def job(t):
    ...     time.sleep(t)
    ...     return threading.current_thread().ident, t

    >>> result = pool.result(job, 0)

The result is an async result:

    >>> ident, sleep = result.get()
    >>> idents = set(t.ident for t in threading.enumerate()
    ...              if t.name == 'zc.resumelb.thread')

    >>> ident in idents and sleep == 0
    True

If we actually sleep, so as to block, we can end up using all of the
threads in the thread pool:

    >>> results = [pool.result(job, 0.01) for i in range(6)]
    >>> set(r.get()[0] for r in results) == idents
    True

When we're done with a pool, it's noce to close it.  This allows us to
wait for pending jobs and close it down in an orderly fashion:

    >>> pool.close()
